# Overview

This program allows you to see how address translations are performed in a
system with segmentation. The segmentation that this system uses is pretty

<!-- NOTE: That top bit is used no where as far as I am concerned -->

simple: an address space has just _two_ segments; further, the top bit of the
virtual address generated by the process determines which segment the address
is in: 0 for segment 0 (where, say, code and the heap would reside) and 1 for
segment 1 (where the stack lives). Segment 0 grows in a positive direction
(towards higher addresses), whereas segment 1 grows in the negative direction.

Visually, the address space looks like this:

```bash
 --------------- virtual address 0
 |    seg0     |
 |             |
 |             |
 |-------------|
 |             |
 |             |
 |             |
 |             |
 |(unallocated)|
 |             |
 |             |
 |             |
 |-------------|
 |             |
 |    seg1     |
 |-------------| virtual address max (size of address space)
```

> To abstract away the subtleties of **physical memory paging** in this
> simulation the stack grows downwards in physical memory just as it does in
> virtual memory.

> Keep in mind that the stack grows downward for stack frames precedence
> and objects allocation but at the byte level every single object is
> written upwards.

With segmentation, as you might recall, there is a base/limit pair of
registers per segment. Thus, in this problem, there are two base/limit
pairs. The segment-0 base tells which physical address the _top_ of segment 0
has been placed in physical memory and the limit tells how big the segment is;
the segment-1 base tells where the _bottom_ of segment 1 has been placed in
physical memory and the corresponding limit also tells us how big the segment
is (or how far it grows in the negative direction).

- **top**: once in physical memory segment-0 grows from the smallest
  addresses at the base to the highest addresses bounded by its length.
  That is why base maps its virtual **top** or **beginning.**
- **bottom**: for segment-1 (stack) it is more subtle. In physical
  memory it grows from the highest addresses bounded by its length down to
  the lowest addresses at the base. That is why base maps its virtual **end**
  or **bottom.**

As before, there are two steps to running the program to test out your
understanding of segmentation. First, run without the "-c" flag to generate a
set of translations and see if you can correctly perform the address
translations yourself. Then, when done, run with the "-c" flag to check your
answers.

For example, to run with the default flags, type:

```sh
prompt> ./segmentation.py
```

or

```sh
prompt> python ./segmentation.py
```

You should see this:

```sh
  ARG seed 0
  ARG address space size 1k
  ARG phys mem size 16k

  Segment register information:

    Segment 0 base  (grows positive) : 0x00001aea (decimal 6890)
    Segment 0 limit                  : 472

    Segment 1 base  (grows negative) : 0x00001254 (decimal 4692)
    Segment 1 limit                  : 450

  Virtual Address Trace
    VA  0: 0x0000020b (decimal:  523) --> PA or segmentation violation?
    VA  1: 0x0000019e (decimal:  414) --> PA or segmentation violation?
    VA  2: 0x00000322 (decimal:  802) --> PA or segmentation violation?
    VA  3: 0x00000136 (decimal:  310) --> PA or segmentation violation?
    VA  4: 0x000001e8 (decimal:  488) --> PA or segmentation violation?

  For each virtual address, either write down the physical address it translates
  to OR write down that it is an out-of-bounds address (a segmentation
  violation). For this problem, you should assume a simple address space with
  two segments: the top bit of the virtual address can thus be used to check
  whether the virtual address is in segment 0 (topbit=0) or segment 1
  (topbit=1). Note that the base/limit pairs given to you grow in different
  directions, depending on the segment, i.e., segment 0 grows in the positive
  direction, whereas segment 1 in the negative.
```

Then, after you have computed the translations in the virtual address trace,
run the program again with the "-c" flag. You will see the following (not
including the redundant information):

```sh
  Virtual Address Trace
    VA  0: 0x0000020b (decimal:  523) --> SEGMENTATION VIOLATION (SEG1)
    VA  1: 0x0000019e (decimal:  414) --> VALID in SEG0: 0x00001c88 (decimal: 7304)
    VA  2: 0x00000322 (decimal:  802) --> VALID in SEG1: 0x00001176 (decimal: 4470)
    VA  3: 0x00000136 (decimal:  310) --> VALID in SEG0: 0x00001c20 (decimal: 7200)
    VA  4: 0x000001e8 (decimal:  488) --> SEGMENTATION VIOLATION (SEG0)
```

As you can see, with -c, the program translates the addresses for you, and
hence you can check if you understand how a system using segmentation
translates addresses.

Of course, there are some parameters you can use to give yourself different
problems. One particularly important parameter is the -s or -seed parameter,
which lets you generate different problems by passing in a different random
seed. Of course, make sure to use the same random seed when you are generating
a problem and then solving it.

There are also some parameters you can use to play with different-sized
address spaces and physical memories. For example, to experiment with
segmentation in a tiny system, you might type:

```sh
.prompt> /segmentation.py -s 100 -a 16 -p 48
ARG seed 100
ARG address space size 16
ARG phys mem size 48

Segment register information:

  Segment 0 base  (grows positive) : 0x00000024 (decimal 36)
  Segment 0 limit                  : 4

  Segment 1 base  (grows negative) : 0x00000019 (decimal 25)
  Segment 1 limit                  : 5

Virtual Address Trace
  VA  0: 0x0000000c (decimal:   12) --> PA or segmentation violation?
  VA  1: 0x00000008 (decimal:    8) --> PA or segmentation violation?
  VA  2: 0x00000001 (decimal:    1) --> PA or segmentation violation?
  VA  3: 0x00000007 (decimal:    7) --> PA or segmentation violation?
  VA  4: 0x00000000 (decimal:    0) --> PA or segmentation violation?
```

which tells the program to generate virtual addresses for a 16-byte address
space placed somewhere in a 48-byte physical memory. As you can see, the
resulting virtual addresses are tiny (12, 8, 1, 7, and 0). As you can also
see, the program picks tiny base register and limit values, as
appropriate. Run with -c to see the answers.

This example should also show you exactly what each base pair means. For
example, segment 0's base is set to a physical address of 36 (decimal) and is
of size 4 bytes. Thus, _virtual_ addresses 0, 1, 2, and 3 are in segment 0 and
valid, and map to physical addresses 36, 37, 38, and 39, respectively.

Slightly more tricky is the negative-direction-growing segment 1. In the tiny
example above, segment 1's base register is set to physical address 25, with a
size of 5 bytes. That means that the _last_ five bytes of the virtual address
space, in this case 11, 12, 13, 14, and 15, are valid virtual addresses, and
that they map to physical addresses 20, 21, 22, 23, and 24, respectively.

If that doesn't make sense, read it again -- you will have to make sense of
how this works in order to do any of these problems.

Note you can specify bigger values by tacking a "k", "m", or even "g" onto the
values you pass in with the -a or -p flags, as in "kilobytes", "megabytes",
and "gigabytes". Thus, if you wanted to do some translations with a 1-MB
address space set in a 32-MB physical memory, you might type:

```sh
prompt> ./segmentation.py -a 1m -p 32m
```

If you want to get even more specific, you can set the base register and limit
register values yourself, with the --b0, --l0, --b1, and --l1 registers. Try
them and see.

Finally, you can always run

```sh
prompt> ./segmentation.py -h
```

to get a complete list of flags and options.

Enjoy!

---

## Questions

1. First letâ€™s use a tiny address space to translate some addresses.
   Hereâ€™s a simple set of parameters with a few different random seeds;
   can you translate the addresses?
   `bash
segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0
segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1
segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 2
`
2. Now, letâ€™s see if we understand this tiny address space weâ€™ve constructed
   (using the parameters from the question above). What is the highest legal
   virtual address in segment 0? What about the lowest legal virtual address in
   segment 1? What are the lowest and highest illegal addresses in this entire
   address space? Finally, how would you run `segmentation.py` with the
   `-A` flag to test if you are right?
3. Letâ€™s say we have a tiny 16-byte address space in a 128-byte physical
   memory. What base and bounds would you set up so as to get the simulator to
   generate the following translation results for the specified address stream:
   valid, valid, violation, ..., violation, valid, valid?
   Assume the following parameters:
   `bash
segmentation.py -a 16 -p 128 \
-A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 \
--b0 ? --l0 ? --b1 ? --l1 ?
`
4. Assume we want to generate a problem where roughly 90%of the randomly
   generated virtual addresses are valid (not segmentation violations). How
   should you configure the simulator to do so? Which parameters are important
   to getting this outcome?

- To achieve this both `--l0` and `--l1` must be 90% if half of `-a`.

5. Can you run the simulator such that no virtual addresses are valid? How?

- I run it as usual but generate invalid addresses with `-A`

## From Virtual Memory Stack to Physical RAM

> **Question:** When the CPU register maps stack virtual addresses to RAM
> physical memory do those addresses keep growing lesser-wise or one time in
> RAM it does matter and they are mapped greater-wise just like the code and
> data segments from virtual address space?

Thank you for clarifying! I appreciate you allowing me to reformulate the
answer. This is an even more nuanced question because the **Stack** is so
critical to program execution, but the core principle of **virtual-to-physical
mapping** remains the same.

The short answer is: **No, the physical addresses where the stack is stored do
not keep growing lesser-wise (downwards). Once an address is mapped to RAM, its
physical location is entirely independent of its virtual growth direction.**

Here is the breakdown of why this is the case, separating the virtual behavior
from the physical reality.

---

### 1. The Stack in Virtual Memory (VAS)

The Stack's primary feature is its **lesser-wise growth (downwards)**,
which is done by design:

- **Virtual Addresses are Decreasing:** When a new function is called, the CPU
  decrements the **Stack Pointer (SP)** to allocate a new **Stack Frame**. This
  frame holds local variables and return addresses, and it always occupies a
  **lower Virtual Address** than the previous frame.
- **The Translation Unit:** In a modern paged system, the Stack is composed
  of multiple virtual pages. When the Stack grows past the boundary of the
  last available virtual page, the OS must allocate a new, lower-addressed
  **virtual page** for the Stack to use.

The CPU is constantly operating on this set of **decreasing virtual
addresses**.

---

### 2. The Stack in Physical Memory (RAM)

The moment the CPU's Memory Management Unit (MMU) performs the translation,
the growth direction from the Virtual Address Space is lost.

#### Physical Memory is Non-Contiguous

The most important concept to remember is that the MMU uses the **Page Table**
to translate the Stack's virtual pages into physical pages (frames) in RAM.

1.  **Demand Paging:** When the Stack needs a new virtual page (i.e., it
    grows downwards into a virtual region it hasn't used before), the OS handles
    a page fault and must find a **free physical frame** _anywhere_ in RAM.
2.  **Physical Address Randomness:** That physical frame's address is
    determined solely by the **free space available in RAM** at that precise
    moment. It could be at a high physical address, a low physical address,
    or somewhere in the middle.

| Stack Virtual Page (Decreasing Order) | Physical Frame (RAM Address) |
| :------------------------------------ | :--------------------------- |
| **Page 1 (Highest VA)**               | 0x8000                       |
| **Page 2 (Next VA Down)**             | 0x3000                       |
| **Page 3 (Lowest VA)**                | 0x9000                       |

As shown above, the **physical addresses** have no ordered relationship
(neither lesser-wise nor greater-wise). The CPU only cares that the **Page
Table Entry (PTE)** correctly maps the virtual address to its corresponding
random physical address.

#### Conclusion

The **Stack** grows **lesser-wise** (downwards) in the **Virtual Address
Space** for structural reasons (to avoid colliding with the upward-growing
Heap). However, in **Physical Memory**, its allocated blocks are entirely
**non-sequential (scattered)**, just like the Heap and the rest of the
program's data segments.

## Stack direction paradox

> **Stacks grow down globally, but build up locally.**

Letâ€™s unpack that insight properly, because itâ€™s one that even seasoned
systems programmers sometimes miss.

---

### ğŸ§  The â€œtwo directionsâ€ paradox

1. **Global growth direction (macro view):**
   - Each new stack _frame_ (function call) is pushed **downward** in memory.
   - The stack pointer (`SP`) **decrements** as you enter a function,
     reserving space â€œbelowâ€ the previous frame.

   So, from a high level:

   ```
   [High addresses]  â† main()
                       funcA()
                       funcB()
   [Low addresses]   â† deepest call
   ```

   The stack â€œgrows downâ€ overall.

2. **Local growth direction (micro view):**
   Inside a single functionâ€™s stack frame:
   - The **frame itself** occupies a downward slice of memory (SP reserved
     a chunk).
   - But **variables, saved registers, and data structures within that frame**
     are addressed **upward**, relative to the frameâ€™s base.

   For instance, on x86:

   ```
   [EBP+8]   â†’  1st function argument
   [EBP+4]   â†’  return address
   [EBP+0]   â†’  old base pointer
   [EBP-4]   â†’  local var #1
   [EBP-8]   â†’  local var #2
   ```

   Notice that within a frame, _each local variable is further down_
   (negative offsets),
   **but multi-byte values themselves still grow upward in address order!**

---

### âš™ï¸ So: downward vs. upward means different things

| Concept                           | Direction | Description                                                                        |
| --------------------------------- | --------- | ---------------------------------------------------------------------------------- |
| **Stack growth**                  | â†“         | New frames push downward, decreasing SP                                            |
| **Address layout within a frame** | â†‘         | Multi-byte objects (like structs, arrays) still use ascending addresses internally |
| **Pointer arithmetic**            | â†‘         | Adding to a pointer moves to higher addresses, as always                           |
| **SP movement**                   | â†“         | Allocating pushes SP down; freeing pops SP up                                      |

---

### ğŸ“Š Analogy

Think of a **notebook flipped upside down**:

- Each new page you write on (a frame) is _below_ the previous one.
- But the lines of text on each page (local variables) are still written
  **top to bottom** (low â†’ high addresses).

---

### ğŸ§© Why the CPU likes this

It lets the **hardware stack discipline** stay simple:

- Pushing something just decrements `SP` and writes bytes upward from there.
- Multi-byte data (e.g. 32-bit integers) are still stored little-endian in
  ascending byte order.
- When a function exits, SP just restores to its previous address, discarding
  the whole block.

Elegant, efficient, and surprisingly symmetric once you â€œseeâ€ both layers
at once.

---

## âš™ï¸ 2. What happens when virtual â†’ physical mapping enters the picture?

Now for the juicy part.

### ğŸ’­ The short version

> The _logical_ growth direction (downward) stays the same, even when virtual
> addresses are mapped to arbitrary physical locations.
>
> What changes is **where** those addresses land in physical memory â€” not
> **how** they behave.

---

### ğŸ§± Base and Bound model (simple segmentation)

Letâ€™s start with old-school **segmentation**, where the CPU does:

```
physical_address = base + virtual_address
```

and enforces:

```
0 <= virtual_address < bound
```

Example:

| Segment | Base | Bound | Notes                               |
| ------- | ---- | ----- | ----------------------------------- |
| Code    | 1000 | 2000  | Virtual 0â†’1999 â†’ Physical 1000â†’2999 |
| Stack   | 9000 | 1000  | Virtual 0â†’999 â†’ Physical 9000â†’9999  |

Now suppose the OS sets up the **stack segment** to start high in physical
memory (base=9000) and uses it _backward_:

```
Virtual addresses:   0 â€¦ 999
Physical addresses: 9000 â€¦ 9999
```

When the programâ€™s _virtual stack pointer_ decreases (say 800 â†’ 799),
the _physical address_ computed will _also_ decrease (9799 â†’ 9798).
So in this simple base+bound world, **both virtual and physical stacks
grow downward.**

The OS just chooses the base high enough so that as you subtract from SP,
you stay within that segment.

---

### ğŸ“¦ Modern Paging model (virtual memory with page tables)

With paging, the picture gets more abstract â€” and thatâ€™s where your
question shines.

Paging says:

> Virtual pages â†’ mapped arbitrarily to physical frames.

So your virtual stack might occupy:

```
Virtual pages: 0x7FFF0000 â†’ 0x7FFFFFFF
Physical pages: 0x00400000 â†’ 0x0040FFFF
```

The **stack still grows downward in virtual space**: each `PUSH` decrements SP.
But in physical RAM, those virtual pages could be mapped _anywhere_ â€”
even non-contiguously!

The CPU doesnâ€™t â€œseeâ€ direction at the physical level; it only sees
â€œfetch the page containing address X.â€
Whether that physical page is above or below another one doesnâ€™t matter.
Thus, **â€œdownward growthâ€ is purely a virtual convention** â€” the
physical layout may not even have a meaningful â€œdownwardâ€ continuity.

---

### ğŸ§­ So to summarize:

| Model                           | Stack growth in virtual space                      | Stack growth in physical space                                      |
| ------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------- |
| **Base + Bound (segmentation)** | Downward (SP decreases)                            | Downward too, since physical = base + virtual                       |
| **Paging (modern CPUs)**        | Downward (SP decreases)                            | Undefined / arbitrary â€” physical mapping can scatter pages anywhere |
| **Semantics**                   | The direction is _logical_ (in address arithmetic) | Physical direction is irrelevant                                    |

---

### ğŸ§© Mental model

Think of it like this:

> The â€œstack grows downwardâ€ rule is a _contract_ between your compiler
> and the virtual address space abstraction.
> The CPUâ€™s physical mapping mechanism is merely a translator; it doesn't
> care which direction â€œdownâ€ means.

---

### ğŸ–¼ï¸ Optional Visual Summary

```
Virtual (what you see)          Physical (what CPU maps)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 0x7FFFFFFF  â”€â”€â”€â”€â”               â”Œâ”€ 0x0040FFFF
                 â†“ SPâ†’           â”‚
 0x7FFFF000  â”€â”€â”€â”€â”˜ â† stack page  â”‚   (could be anywhere)
                                 â”‚
 0x7FFFE000  â”€â”€â”€â”€â”               â”œâ”€ 0x00C12000
                 â†“               â”‚
 0x7FFFD000  â”€â”€â”€â”€â”˜               â””â”€ 0x001AB000
```

The **virtual stack** is contiguous and downward,
but the **physical mapping** can hop around in RAM.

Yet from the programâ€™s point of view, itâ€™s perfectly smooth.

---
